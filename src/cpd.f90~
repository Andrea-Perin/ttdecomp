MODULE CPD

  USE DEBUGGER
  USE TENSOR_TYPES
  USE MODE_N
  USE SWAP_AXIS
  USE MAT_UTILS
  
  IMPLICIT NONE

CONTAINS

!!$  SUBROUTINE CDP2()
!!$  END SUBROUTINE CDP2
  

  SUBROUTINE CDP3(tensor, rank, thresh, factors, error)
!!$==========================================================================================================     
!!$    Computes the Alternating Least Squares algorithm for the computation of the CDP decomposition.
!!$    Each factor matrix is updated as
!!$    B^(n) <- X_(n) (KHRAO_{k/=n} B^(k)) (HAD_{k/=n} B^(k)^T B^(k))^{INV}
!!$    After this, the mean squared error is computed; the algorithm goes on as long as the error
!!$    is larger than some threshold.
!!$    INOUT:
!!$    - tensor    : (REAL*8) the input matrix to be inverted
!!$    - rank      : (INTEGER*4) the rank of the decomposition (nunmber of factors in the linear combination)
!!$    - thresh    : (REAL*8) the threshold on the error
!!$    - factors   : (matrix_list) the list of the factor matrices. Should be 3 elements long
!!$    - error     : (REAL*8) the reconstruction error
!!$==========================================================================================================
    ! INOUT VARIABLES
    TYPE(DTENSOR3) :: tensor
    INTEGER*4 :: rank
    REAL*8 :: tol, error, thresh
    TYPE(matrix_list) :: factors
    ! UTILITY VARIABLES
    INTEGER*4 :: ii, jj
    REAL*8, ALLOCATABLE :: krprod(:,:), hadprod(:,:), reconstructed(:,:), krprodrec(:,:)
    REAL*8 :: newerror
    INTEGER*4 :: sizes(3,2), ridx(2), index(3), running_size, cnt
    ! FUNCTION DEFINITION
    ! ALLOCATE THE FACTOR MATRICES
    ALLOCATE(factors(1)%matr(SIZE(tensor,1),rank))
    ALLOCATE(factors(2)%matr(SIZE(tensor,2),rank))
    ALLOCATE(factors(3)%matr(SIZE(tensor,3),rank))
    ! STORE THE DIMENSIONS OF THE FACTOR MATRICES
    DO ii=1,SIZE(factors)
       sizes(ii,1) = SIZE(factors(ii)%matr,1)
       sizes(ii,2) = rank
    END DO
    ! ALLOCATE THE RECONSTRUCTED TENSOR
    ALLOCATE(reconstructed(sizes(1,1),PRODUCT(sizes(2:,1))))
    ALLOCATE(krprodrec(PRODUCT(sizes(2:,1)),rank))
    ! RANDOMLY INITIALIZE THE MATRICES
    CALL RANDOM_NUMBER(factors(1)%matr)
    CALL RANDOM_NUMBER(factors(2)%matr)
    CALL RANDOM_NUMBER(factors(3)%matr)
    ! REPEAT UNTIL CONVERGENCE
    error=1e3*SIZE(tensor)
    cnt = 0
    DO WHILE (error.GT.thresh).AND.(cnt.LT.20)
       cnt=cnt+1
       ! CYCLE OVER THE FACTOR MATRICES
       DO ii=1,SIZE(factors)
          ! REINDEXING: that excludes the index ii
          index = (/(jj, jj=1,SIZE(factors),1)/)
          ridx = PACK(index, index/=ii)
          ! COMPUTE THE KHATRI-RAO PRODUCTORY
          ! allocate the necessary space
          ALLOCATE(krprod(PRODUCT(sizes(:,1))/sizes(ii,1),rank))
          ! keep track of the number of rows
          running_size = sizes(ridx(1),1)*sizes(ridx(2),1)
          ! compute the intial Khatri-Rao product
          krprod(1:running_size,:) = (factors(ridx(1))%matr).KHRAO.(factors(ridx(2))%matr)
          ! continue the product
          DO jj=3,SIZE(ridx)
             krprod(1:running_size*sizes(ridx(jj),1),:) = krprod(1:running_size,:).KHRAO.factors(ridx(jj))%matr
             running_size = running_size*sizes(ridx(jj),1)
          END DO
          ! COMPUTE THE HADAMARD PRODUCT
          ALLOCATE(hadprod(rank,rank))
          hadprod = 1D0
          DO jj=1,SIZE(ridx)-1
             hadprod = hadprod.HAD.MTML(factors(ridx(jj))%matr,TRANSPOSE(factors(ridx(jj))%matr))
          END DO
          hadprod = PINV(hadprod)
          ! COMPOSE EVERYTHING
          factors(ii)%matr = MTML(MTML(tensor.MODE.ii,krprod),hadprod)
       END DO

       !===================================================================================================
       ! RECONSTRUCT THE STARTING TENSOR
       ! compute the Khatri-Rao productory of factor matrices
       krprodrec(1:sizes(2,1)*sizes(3,1),:) = factors(2)%matr.KHRAO.factors(3)%matr
       running_size = sizes(2,1)*sizes(3,1)
       DO ii=4,SIZE(factors)
          krprodrec(1:running_size*sizes(ii,1),:) = krprodrec(1:running_size,:).KHRAO.factors(ii)%matr
          running_size=running_size**sizes(ii,1)
       END DO
       ! put everything together
       reconstructed = MTML(factors(1)%matr,TRANSPOSE(krprodrec))

       !===================================================================================================
       ! COMPUTE THE MEAN SQUARE ERROR
       newerror = SUM((tensor.MODE.1 - reconstructed)**2)/PRODUCT(sizes(:,1))
       ! if the mean square error is not decreasing: print on screen!
       IF (newerror.GT.error) THEN
          WRITE(*,*) "WARNING: error did not decrease."
       END IF
       error = newerror
    END DO
  END SUBROUTINE CDP3


  
END MODULE CPD
